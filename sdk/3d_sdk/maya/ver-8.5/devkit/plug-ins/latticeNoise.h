//-
// ==========================================================================
// Copyright (C) 1995 - 2006 Autodesk, Inc. and/or its licensors.  All 
// rights reserved.
//
// The coded instructions, statements, computer programs, and/or related 
// material (collectively the "Data") in these files contain unpublished 
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its 
// licensors, which is protected by U.S. and Canadian federal copyright 
// law and by international treaties.
//
// The Data is provided for use exclusively by You. You have the right 
// to use, modify, and incorporate this Data into other products for 
// purposes authorized by the Autodesk software license agreement, 
// without fee.
//
// The copyright notices in the Software and this entire statement, 
// including the above license grant, this restriction and the 
// following disclaimer, must be included in all copies of the 
// Software, in whole or in part, and all derivative works of 
// the Software, unless such copies or derivative works are solely 
// in the form of machine-executable object code generated by a 
// source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. 
// AUTODESK DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED 
// WARRANTIES INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF 
// NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR 
// PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE, OR 
// TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS LICENSORS 
// BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL, 
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK 
// AND/OR ITS LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY 
// OR PROBABILITY OF SUCH DAMAGES.
//
// ==========================================================================
//+


#include <maya/MPxCommand.h>
#include <maya/MPxNode.h>

//
//  Class: latticeNoiseCmd
//
//  Description:
//      The latticeNoise command creates a new lattice (ffd) deformer.  A 
//      latticeNoise node is placed between the deformed lattice shape and the 
//      actual deformer node.  This causes the deformed object to wobble as 
//      random continuous noise is added to the pointes of the lattice.
//
//  eg
//     This causes the currently selected object to be deformed
//  
//       latticeNoise;
//
//     This causes the specified geometry to be deformed
//
//       latticeNoise sphereShape1; 
//

class MArgList;

class latticeNoiseCmd : public MPxCommand
{
public:
					latticeNoiseCmd() {};
	virtual			~latticeNoiseCmd() {}; 

	MStatus			doIt( const MArgList& args );
	static void*	creator();
};

//
//  Class: latticeNoiseNode
//
//  Description:
//      A "latticeNoise" node adds random noise to lattice geometry over time.
//      This makes the geometry being deformed by the lattice look like 
//      wobbly jello.
//
//
//  Node:       latticeNoise
//
//  Attributes: input     - input lattice 
//              amplitude - amplitude of the noise
//              frequency - frequency of the noise
//              time      - the current time
//              output    - the modified lattice
//      

class latticeNoiseNode : public MPxNode
{
public:
						latticeNoiseNode() {};
	virtual				~latticeNoiseNode() {}; 

    virtual MStatus		compute( const MPlug& plug, MDataBlock& data );
	static  void*		creator();
	static  MStatus		initialize();

public:
	static  MObject     input;     // The input lattice.
	static  MObject     amplitude; // The noise amplitude.
	static  MObject     frequency; // The noise frequency.
	static  MObject     time;      // The time.
	static  MObject     output;    // The output lattice.
	static	MTypeId		id;        // The IFF type id
};

//
//  Class: noise
//
//  Description:
//      The noise class is used for generating pseudo-random continuous noise.
//      The noise values generated are always between 0 and 1.
//
//      The technique used is a simple lattice noise algorithm based upon one 
//      by Ken Perlin.  This particular implementation is adapted from 
//      Darwyn Peachey's (Texturing and Modeling: a Procedural Approach,
//		S. Ebert Editor, 1994).
//

#define TABLE_SIZE 256

extern const int kTableMask;
#define MODPERM(x) permtable[(x)&kTableMask]

typedef struct {
	float x;
	float y;
	float z;
} pnt;

class noise {
public:

	static float  atValue( float x );
	static float  atPoint( float x, float y, float z ); 

	static pnt    atPointAndTime( float x, float y, float z, float t );

	static void   initTable( long seed );

private:

	static int    permtable   [256];
	static float  valueTable1 [256];
	static float  valueTable2 [256];
	static float  valueTable3 [256];
	static int    isInitialized;
	
	static float  spline( float x, float knot0, float knot1, float knot2, 
						  float knot3 );

	static float  value( int x, int y, int z, float table[] = valueTable1 );
	static float  value( int x, int y, int z, int t,
						 float table[] = valueTable1 );
	static float  value( int x, float table[] = valueTable1 );


};
 

inline float noise::value( int x, int y, int z, int t, float table[] ) {
	return table[MODPERM( x + MODPERM( y + MODPERM( z + MODPERM( t ) ) ) )];
}

inline float noise::value( int x, int y, int z, float table[] ) {
	return table[MODPERM( x + MODPERM( y + MODPERM( z ) ) )];
}

inline float noise::value( int x, float table[] ) {
	return table[MODPERM( x )];
}
